<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ancient Expedition</title>
    <style>
        :root {
            --color-cream-50: rgba(252, 252, 249, 1);
            --color-slate-900: rgba(19, 52, 59, 1);
            --color-teal-500: rgba(33, 128, 141, 1);
            --font-family-base: "FKGroteskNeue", "Geist", "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family-base);
            background: #1a1410;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            color: #2c1810;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 500px;
            height: 700px;
            background: linear-gradient(to bottom, #4a3829, #2c1810);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
            border-radius: 12px;
            overflow: hidden;
        }

        /* SVG overlays for enemies and player should sit above the canvas but below UI overlays */
        .enemy-svg, .player-svg {
            z-index: 5;
            user-select: none;
            -webkit-user-drag: none;
        }

        /* Hint browser to composite transforms/opacities on GPU and smooth opacity swaps */
        .player-svg {
            transition: opacity 120ms linear;
            will-change: transform, opacity;
            -webkit-transform: translate3d(0,0,0);
        }
        /* store card styles */
        .store-card {
            background: rgba(36, 26, 18, 0.9);
            border: 1px solid rgba(212,175,55,0.12);
            padding: 8px;
            display:flex;
            align-items:center;
            gap:12px;
            border-radius:8px;
        }
        .store-card img { width:64px; height:64px; object-fit:contain; }
        .store-card .meta { flex:1; }
        .store-card .meta .title { color:#FFD700; font-weight:700; }
        .store-card .meta .price { color:#d2a679; font-size:13px; }
        .store-card button { padding:6px 10px; font-size:13px; }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: pointer;
            touch-action: none;
        }

        /* on-screen hold button for mobile */
        .touch-hold {
            position: absolute;
            right: 18px;
            bottom: 18px;
            z-index: 20;
            width: 84px;
            height: 84px;
            border-radius: 50%;
            background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
            border: 2px solid rgba(255,255,255,0.06);
            color: #f4e8d0;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            backdrop-filter: blur(4px);
            box-shadow: 0 6px 18px rgba(0,0,0,0.4);
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        /* hide by default on desktop; visible on small screens */
        .touch-hold.hidden { display: none; }

        @media (max-width: 600px) {
            #gameContainer { max-width: 100%; height: 92vh; border-radius: 8px; }
            .title { font-size: 22px; }
            .subtitle { font-size: 14px; }
            .touch-hold.hidden { display: flex; }
            .store-card img { width:56px; height:56px; }
            .start-button, .reset-button { padding: 12px 16px; font-size: 16px; }
        }

        /* Fullscreen button (small) */
        .fullscreen-btn {
            position: absolute;
            right: 18px;
            top: 18px;
            z-index: 30;
            padding: 8px 10px;
            border-radius: 8px;
            background: rgba(0,0,0,0.24);
            color: #f4e8d0;
            border: 1px solid rgba(255,255,255,0.04);
            font-size: 12px;
            cursor: pointer;
            backdrop-filter: blur(4px);
        }

        /* when container is in fullscreen mode, make it occupy the full viewport cleanly */
        #gameContainer.fullscreen-active {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            max-width: none !important;
            border-radius: 0 !important;
            box-shadow: none !important;
            z-index: 9999 !important;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(42, 30, 20, 0.92);
            z-index: 10;
            transition: opacity 0.3s ease;
        }

        .overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .title {
            font-size: 36px;
            font-weight: 600;
            color: #f4e8d0;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.5);
            letter-spacing: -0.5px;
            padding: 0 20px;
        }

        .subtitle {
            font-size: 16px;
            color: #d2a679;
            text-align: center;
            margin-bottom: 30px;
            max-width: 350px;
            line-height: 1.6;
            padding: 0 20px;
        }

        .instructions {
            background: rgba(244, 232, 208, 0.15);
            border: 2px solid rgba(210, 166, 121, 0.4);
            border-radius: 10px;
            padding: 20px 30px;
            margin: 20px;
            max-width: 350px;
            backdrop-filter: blur(5px);
        }

        .instruction-item {
            color: #f4e8d0;
            font-size: 14px;
            margin: 10px 0;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .instruction-icon {
            width: 30px;
            height: 30px;
            background: rgba(210, 105, 30, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }

        .start-button {
            background: linear-gradient(135deg, #d2691e, #a0522d);
            color: #f4e8d0;
            border: 3px solid rgba(244, 232, 208, 0.4);
            padding: 15px 40px;
            font-size: 18px;
            font-weight: 600;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            margin-top: 20px;
        }

        .start-button:hover {
            background: linear-gradient(135deg, #ff7f50, #d2691e);
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(0, 0, 0, 0.4);
        }

        .start-button:active {
            transform: translateY(0);
        }

        .game-over-content {
            text-align: center;
        }

        .final-score {
            font-size: 24px;
            color: #f4e8d0;
            margin: 20px 0;
        }

        .score-label {
            font-size: 14px;
            color: #d2a679;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
        }

        .score-value {
            font-size: 48px;
            font-weight: 700;
            color: #d2691e;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .medal-container {
            margin: 30px 0;
        }

        .medal {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border: 4px solid rgba(244, 232, 208, 0.3);
        }

        .medal.bronze {
            background: linear-gradient(135deg, #CD7F32, #8B5A2B);
        }

        .medal.silver {
            background: linear-gradient(135deg, #C0C0C0, #A8A8A8);
        }

        .medal.gold {
            background: linear-gradient(135deg, #FFD700, #FFA500);
        }

        .restart-hint {
            color: #d2a679;
            font-size: 14px;
            margin-top: 20px;
            font-style: italic;
        }

        .small-stats {
            display: flex;
            gap: 12px;
            margin-top: 12px;
            color: #d2a679;
            font-size: 13px;
            align-items: center;
        }

        .reset-button {
            background: transparent;
            color: #d2a679;
            border: 1px solid rgba(210,166,121,0.2);
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
        }

        .danger-label {
            color: #FF4136;
            font-weight: 700;
            text-shadow: 0 2px 6px rgba(0,0,0,0.6);
        }

        @media (max-width: 520px) {
            #gameContainer {
                max-width: 100%;
                height: 100vh;
                border-radius: 0;
            }

            .title {
                font-size: 28px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="startScreen" class="overlay">
            <h1 class="title">Ancient Expedition</h1>
            <p class="subtitle">Explore ancient Egyptian tombs with your mystical wings of pure light- collect treasures and avoid ancient traps!</p>
            <div class="small-stats">
                <div id="savedTreasuresDisplay">Saved Treasures: 0</div>
                <div id="savedBestDisplay">Best: 0m</div>
                <button class="reset-button" onclick="resetProgress()">Reset Progress</button>
            </div>
            <div style="margin-top:8px; display:flex; gap:8px; justify-content:center;">
                <button id="startStoreBtn" class="start-button" onclick="openStore()">Store</button>
            </div>
            <div class="instructions">
                <div class="instruction-item">
                    <span class="instruction-icon">‚ú®</span>
                    <span>HOLD to activate jetpack and rise</span>
                </div>
                <div class="instruction-item">
                    <span class="instruction-icon">‚ö°</span>
                    <span>Avoid zappers, lasers &amp; guardian projectiles</span>
                </div>
                <div class="instruction-item">
                    <span class="instruction-icon">üè∫</span>
                    <span>Collect golden scarabs, ankhs &amp; gems</span>
                </div>
            </div>
            <button id="startBeginBtn" class="start-button" onclick="startGame()">Begin Expedition</button>
        </div>

        <div id="gameOverScreen" class="overlay hidden">
            <div class="game-over-content">
                <h1 class="title">Expedition Complete</h1>
                <div class="final-score">
                    <div class="score-label">Distance Traveled</div>
                    <div class="score-value" id="finalScore">0</div>m
                </div>
                <div class="final-score" style="font-size: 18px; margin-top: 10px;">
                    <div class="score-label" style="font-size: 12px;">Treasures Collected</div>
                    <div class="score-value" id="treasureScore" style="font-size: 32px;">0</div>
                </div>
                        <div id="savedTotalContainer" style="text-align:center; margin-top:6px; color:#d2a679; font-size:14px;">Total Saved: <span id="savedTotalDisplay">0</span></div>
                        <div class="medal-container" id="medalContainer"></div>
                        <button id="gameOverRestartBtn" class="start-button" onclick="restartGame()">New Expedition</button>
                        <button id="gameOverStoreBtn" class="start-button" onclick="openStore()" style="margin-left:8px;">Store</button>
                        <p class="restart-hint">Press SPACE or click to restart</p>
                        <div class="small-stats" style="justify-content:center; margin-top: 18px;">
                            <div id="savedBestDisplayGameover">Best: 0m</div>
                            <button class="reset-button" onclick="resetProgress()">Reset Progress</button>
                        </div>
            </div>
        </div>
        <div id="storeScreen" class="overlay hidden">
            <div style="width: 90%; max-width: 420px; color: #f4e8d0; text-align:left;">
                <h2 style="margin-bottom:8px;">Character Store</h2>
                <p style="color:#d2a679; margin-bottom:12px;">Buy and select your playable character. Prices are paid from your saved total treasures.</p>
                <div id="storeList" style="display:flex; flex-direction:column; gap:12px; max-height:380px; overflow:auto;"></div>
                <div style="display:flex; gap:8px; margin-top:14px; justify-content:flex-end;">
                    <button class="start-button" onclick="closeStore()" style="padding:10px 18px; font-size:14px;">Close</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        
        // logical canvas/game dimensions (CSS pixels) - declare early to avoid TDZ
        let GW = canvas.clientWidth || 500;
        let GH = canvas.clientHeight || 700;
        // flag for overlay interactivity; declare early to avoid TDZ when overlay/start handlers run
        let overlayInteractive = false;
        // Set canvas size
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            // support high-DPI screens: scale backing store by devicePixelRatio
            const ratio = Math.max(1, window.devicePixelRatio || 1);
            const width = container.clientWidth;
            const height = container.clientHeight;
            // set CSS size
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            // set backing store size
            canvas.width = Math.floor(width * ratio);
            canvas.height = Math.floor(height * ratio);
            // use setTransform so existing drawing code can continue using CSS pixels
            ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
            // logical (CSS) game dimensions for scripts to use
            GW = width;
            GH = height;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Game configuration
        const config = {
            gravity: 0.4,
            jetpackThrust: 0.6,
            scrollSpeed: 5,
            scrollSpeedMax: 12,
            scrollAcceleration: 0.001,
            playerX: 150,
            playerSize: 40
        };

        // Small helpers
        function lerp(a, b, t) { return a + (b - a) * t; }

        // Game state
        let gameState = 'start';
        let distance = 0;
        let treasures = 0;
        let frameCount = 0;
        let scrollSpeed = config.scrollSpeed;
        let player = null;
        let obstacles = [];
        let collectibles = [];
        let powerups = [];
        let particles = [];
        let ambientParticles = [];
        let debris = [];
        let decals = []; // persistent ground decals (scorch, dust)
        // logical canvas/game dimensions (CSS pixels) - already declared above; initialize values
        GW = canvas.clientWidth || 500;
        GH = canvas.clientHeight || 700;
        
        class Decal {
            constructor(x, y, color, size) {
                this.x = x;
                this.y = y;
                this.size = size || (12 + Math.random() * 40);
                this.rotation = Math.random() * Math.PI * 2;
                // shorter-lived decals to avoid persistent dark smog
                this.life = 180 + Math.random() * 180; // frames to fade
                this.color = color || 'rgba(60,40,30,0.35)';
            }

            update() {
                this.life -= 1;
            }

            draw() {
                const alpha = Math.max(0, Math.min(1, this.life / 600));
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                // lower base alpha so overlapping decals don't create a heavy smog
                ctx.globalAlpha = 0.18 * alpha;
                const grad = ctx.createRadialGradient(0, 0, this.size * 0.1, 0, 0, this.size);
                grad.addColorStop(0, this.color);
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(-this.size, -this.size/2, this.size*2, this.size);
                ctx.restore();
                ctx.globalAlpha = 1;
            }
        }
            // screen shake and flash for impactful explosions
            let screenShake = 0;
            let screenShakeTimer = 0;
            let flashAlpha = 0;
            // flash decay controls how quickly the screen flash fades (higher = faster)
            let flashDecay = 0.28;
        let backgroundOffset = 0;
        let isHoldingJetpack = false;
        // Support multiple simultaneous powerups
        let activePowerups = {}; // map: type -> remaining frames
        let gameOverTimerId = null;
        overlayInteractive = false; // becomes true when the game-over overlay is fully shown

        // Player (Archaeologist) class
        class Player {
            constructor() {
                this.x = config.playerX;
                this.y = GH / 2;
                this.velocity = 0;
                this.rotation = 0; // degrees
                this.size = config.playerSize;
                this.jetpackActive = false;
                this.prevVelocity = 0;
                this.satchelAngle = 0;

                // SVG overlay setup (preferred immediately; falls back to canvas if error)
                try {
                    this.svgEl = document.createElement('img');
                    this.svgEl.className = 'player-svg';
                    this.svgEl.style.position = 'absolute';
                    this.svgEl.style.pointerEvents = 'none';
                    this.svgEl.style.transformOrigin = '50% 50%';
                    this.svgEl.style.opacity = '0';
                    this.svgPreferred = true; // prefer overlay when available
                    this.svgLoaded = false;
                    this.currentSprite = null;

                    this.svgEl.onload = () => {
                        this.svgLoaded = true;
                        try { this.svgEl.style.opacity = '1'; } catch (e) {}
                    };
                    this.svgEl.onerror = () => { try { this.svgEl.parentNode && this.svgEl.parentNode.removeChild(this.svgEl); } catch (e){}; this.svgEl = null; this.svgLoaded = false; this.svgPreferred = false; };

                    // initialize to selected character (fallback to classic)
                    const sel = getSelectedChar();
                    const ch = characters.find(c => c.id === sel) || characters[0];
                    const initial = (imageCache[ch.run] && imageCache[ch.run].src) ? imageCache[ch.run].src : (ch.run || 'characterrun.svg');
                    this.currentSprite = initial;
                    this.svgEl.src = initial;
                    const container = document.getElementById('gameContainer');
                    if (container) container.appendChild(this.svgEl);
                } catch (e) {
                    this.svgEl = null;
                    this.svgPreferred = false;
                    this.svgLoaded = false;
                }
            }

            update() {
                // apply thrust or gravity
                if (this.jetpackActive) {
                    this.velocity -= config.jetpackThrust;
                    this.velocity = Math.max(this.velocity, -8);
                } else {
                    this.velocity += config.gravity;
                }

                // move
                this.y += this.velocity;

                // smooth rotation based on vertical velocity
                const targetRot = Math.max(-25, Math.min(25, this.velocity * 2));
                this.rotation = lerp(this.rotation, targetRot, 0.12);

                // screen bounds and landing detection
                if (this.y < 30) this.y = 30;
                const groundY = GH - 110;
                if (this.y > groundY) {
                    const impact = this.velocity;
                    if (impact > 2.5) {
                        for (let i = 0; i < 10; i++) {
                            particles.push(new Particle(this.x + (Math.random() - 0.5) * 24, groundY + 6 + Math.random() * 6, 'smoke'));
                        }
                    }
                    this.y = groundY;
                    this.velocity = 0;
                }

                this.prevVelocity = this.velocity;

                // Update SVG overlay position/rotation/size if present
                if (this.svgEl && this.svgEl.parentNode) {
                    const w = this.size * 1.8;
                    const h = this.size * 1.8;
                    this.svgEl.style.width = w + 'px';
                    this.svgEl.style.height = h + 'px';
                    this.svgEl.style.left = (this.x - w / 2) + 'px';
                    this.svgEl.style.top = (this.y - h / 2) + 'px';
                    const deg = this.rotation;
                    this.svgEl.style.transform = `translate(0px,0px) rotate(${deg}deg)`;
                    // switch sprite based on flying state
                    const sel = getSelectedChar();
                    const ch = characters.find(c => c.id === sel) || characters[0];
                    const desired = this.jetpackActive ? (ch.fly || 'characterfly.svg') : (ch.run || 'characterrun.svg');
                    // If desired sprite changed, attempt to swap using the preloaded cache when possible
                    if (this.currentSprite !== desired) {
                        this.currentSprite = desired;
                        const cached = imageCache[desired];
                        if (cached && cached.complete) {
                            // immediate swap (cached)
                            try { this.svgEl.style.opacity = '1'; } catch (e) {}
                            this.svgLoaded = true;
                            this.svgEl.src = cached.src;
                        } else {
                            // not cached/decoded yet: hide until loaded to avoid showing a mismatched frame
                            this.svgLoaded = false;
                            try { this.svgEl.style.opacity = '0'; } catch (e) {}
                            this.svgEl.src = desired;
                        }
                    }
                }

                // If SVG overlay is preferred, clear any existing 'streak' particles so no blue lines remain
                if (this.svgPreferred) {
                    for (let i = particles.length - 1; i >= 0; i--) {
                        if (particles[i].type === 'streak') particles.splice(i, 1);
                    }
                }
            }

            activateJetpack() { this.jetpackActive = true; }
            deactivateJetpack() { this.jetpackActive = false; }

            draw() {
                // subtle idle bob when not thrusting
                const bob = this.jetpackActive ? 0 : Math.sin(frameCount * 0.06) * 2;

                ctx.save();
                ctx.translate(this.x, this.y + bob);

                // squash & stretch based on vertical velocity
                const v = Math.max(-12, Math.min(12, this.velocity));
                const stretch = Math.max(-0.12, Math.min(0.12, -v * 0.01));
                const scaleY = 1 - stretch;
                const scaleX = 1 + stretch * 0.6;
                ctx.scale(scaleX, scaleY);
                ctx.rotate(this.rotation * Math.PI / 180);

                // satchel trailing angle (secondary motion)
                const targetSatchel = -this.velocity * 1.6; // degrees
                this.satchelAngle = lerp(this.satchelAngle, targetSatchel, 0.12);

                // Draw archaeologist body (canvas fallback only)
                if (!this.svgLoaded) {
                    ctx.fillStyle = '#C19A6B';
                    ctx.fillRect(-8, -5, 16, 18);

                    // Head
                    ctx.fillStyle = '#D2B48C';
                    ctx.beginPath();
                    ctx.arc(0, -12, 8, 0, Math.PI * 2);
                    ctx.fill();

                    // Hat
                    ctx.fillStyle = '#8B7355';
                    ctx.beginPath();
                    ctx.ellipse(0, -18, 12, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillRect(-5, -18, 10, 6);

                    // Satchel with slight trailing rotation
                    ctx.save();
                    ctx.translate(5 + 4, 5);
                    ctx.rotate(this.satchelAngle * Math.PI / 180);
                    ctx.translate(- (5 + 4), -5);
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(5, 0, 8, 10);
                    ctx.strokeStyle = '#8B4513';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(5, 0, 8, 10);
                    ctx.restore();

                    // Arms
                    ctx.fillStyle = '#C19A6B';
                    ctx.fillRect(-12, 2, 4, 10);
                    ctx.fillRect(8, 2, 4, 10);

                    // Legs
                    ctx.fillRect(-6, 13, 5, 8);
                    ctx.fillRect(1, 13, 5, 8);
                }

                ctx.restore();
            }

            checkCollision(obstacle) {
                const padding = 5;
                const playerLeft = this.x - this.size / 2 + padding;
                const playerRight = this.x + this.size / 2 - padding;
                const playerTop = this.y - this.size / 2 + padding;
                const playerBottom = this.y + this.size / 2 - padding;

                if (obstacle.type === 'zapper') {
                    const hitTop = playerTop < obstacle.gapY;
                    const hitBottom = playerBottom > obstacle.gapY + obstacle.gap;
                    const inRange = playerRight > obstacle.x && playerLeft < obstacle.x + obstacle.width;
                    return inRange && (hitTop || hitBottom);
                } else if (obstacle.type === 'laser') {
                        // Laser is rotated; calculate distance from player center to laser segment
                        const x1 = obstacle.x;
                        const y1 = obstacle.y;
                        const x2 = obstacle.x + Math.cos(obstacle.rotation) * obstacle.length;
                        const y2 = obstacle.y + Math.sin(obstacle.rotation) * obstacle.length;

                        function distToSegment(px, py, x1, y1, x2, y2) {
                            const A = px - x1;
                            const B = py - y1;
                            const C = x2 - x1;
                            const D = y2 - y1;

                            const dot = A * C + B * D;
                            const len_sq = C * C + D * D;
                            let param = -1;
                            if (len_sq !== 0) param = dot / len_sq;

                            let xx, yy;
                            if (param < 0) {
                                xx = x1;
                                yy = y1;
                            } else if (param > 1) {
                                xx = x2;
                                yy = y2;
                            } else {
                                xx = x1 + param * C;
                                yy = y1 + param * D;
                            }

                            const dx = px - xx;
                            const dy = py - yy;
                            return Math.sqrt(dx * dx + dy * dy);
                        }

                        const distanceToBeam = distToSegment((this.x), (this.y), x1, y1, x2, y2);
                        // beam half-width ~8
                        return distanceToBeam < (this.size / 2 + 8);
                } else if (obstacle.type === 'missile') {
                    const dx = this.x - obstacle.x;
                    const dy = this.y - obstacle.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    return dist < this.size / 2 + obstacle.size - padding;
                }
                return false;
            }

            checkCollectible(collectible) {
                const dx = this.x - collectible.x;
                const dy = this.y - collectible.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                return dist < this.size / 2 + collectible.size;
            }
        }

        // Obstacle classes
        class Zapper {
            constructor() {
                this.type = 'zapper';
                this.x = GW;
                this.width = 60;
                this.gap = 180;
                this.gapY = Math.random() * (GH - this.gap - 150) + 80;
                this.scored = false;
                this.pulsePhase = Math.random() * Math.PI * 2;
            }

            update() {
                this.x -= scrollSpeed;
                this.pulsePhase += 0.1;
            }

            draw() {
                const pulse = Math.sin(this.pulsePhase) * 0.3 + 0.7;
                
                // Top obelisk
                this.drawObelisk(this.x, 0, this.width, this.gapY);
                // Bottom obelisk
                this.drawObelisk(this.x, this.gapY + this.gap, this.width, GH - this.gapY - this.gap - 80);
                
                // Energy field
                ctx.save();
                ctx.globalAlpha = pulse;
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00FFFF';
                
                const gradient = ctx.createLinearGradient(this.x, this.gapY, this.x + this.width, this.gapY + this.gap);
                gradient.addColorStop(0, 'rgba(0, 255, 255, 0.6)');
                gradient.addColorStop(0.5, 'rgba(0, 206, 209, 0.4)');
                gradient.addColorStop(1, 'rgba(0, 255, 255, 0.6)');
                ctx.fillStyle = gradient;
                ctx.fillRect(this.x + 5, this.gapY, this.width - 10, this.gap);
                
                // Energy particles
                for (let i = 0; i < 3; i++) {
                    const y = this.gapY + Math.random() * this.gap;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(this.x + this.width / 2, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }

            drawObelisk(x, y, width, height) {
                const gradient = ctx.createLinearGradient(x, y, x + width, y + height);
                gradient.addColorStop(0, '#8B8589');
                gradient.addColorStop(0.5, '#A0A0A0');
                gradient.addColorStop(1, '#696969');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x, y, width, height);
                
                // Ankh symbol
                if (height > 60) {
                    ctx.strokeStyle = '#D4AF37';
                    ctx.lineWidth = 3;
                    const cy = y + height / 2;
                    ctx.beginPath();
                    ctx.arc(x + width / 2, cy - 8, 6, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(x + width / 2, cy - 2);
                    ctx.lineTo(x + width / 2, cy + 15);
                    ctx.moveTo(x + width / 2 - 8, cy + 5);
                    ctx.lineTo(x + width / 2 + 8, cy + 5);
                    ctx.stroke();
                }
                
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, width, height);
            }

            isOffScreen() {
                return this.x + this.width < 0;
            }
        }

        class Laser {
            constructor() {
                this.type = 'laser';
                this.x = GW;
                this.y = Math.random() * (GH - 200) + 100;
                this.length = 300;
                this.rotation = 0;
                this.rotationSpeed = 0.01;
                this.scored = false;
            }

            update() {
                this.x -= scrollSpeed;
                this.rotation += this.rotationSpeed;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // Laser source (pharaoh face)
                ctx.fillStyle = '#B8860B';
                ctx.fillRect(-20, -15, 20, 30);
                ctx.fillStyle = '#D4AF37';
                ctx.fillRect(-15, -10, 10, 20);
                
                // Laser beam - make wider and add danger cues
                const beamWidth = 10;
                ctx.shadowBlur = 24;
                ctx.shadowColor = 'rgba(255,80,0,0.9)';
                const laserGradient = ctx.createLinearGradient(0, -beamWidth/2, this.length, beamWidth/2);
                laserGradient.addColorStop(0, 'rgba(255, 100, 0, 0.95)');
                laserGradient.addColorStop(0.5, 'rgba(255, 60, 0, 0.6)');
                laserGradient.addColorStop(1, 'rgba(255, 120, 0, 0.25)');
                ctx.fillStyle = laserGradient;
                ctx.fillRect(0, -beamWidth/2, this.length, beamWidth);

                // Danger indicator intentionally simplified (no skull)
                // beam visual remains red and glowing; avoid skull icon
                
                ctx.restore();
            }

            isOffScreen() {
                return this.x + this.length < 0;
            }
        }

        class Missile {
            constructor(targetY) {
                this.type = 'missile';
                this.x = GW + 50;
                this.y = targetY;
                this.targetY = targetY;
                this.size = 15;
                this.speed = 4;
                this.rotation = 0;
                this.scored = false;
                // Missiles are drawn on the canvas for better performance on mobile
                this.svgEl = null;
            }

            update() {
                this.x -= this.speed;
                if (player) {
                    const dy = player.y - this.y;
                    this.y += dy * 0.02;
                    this.rotation = Math.atan2(dy, -this.speed);
                }
                // Update overlayed SVG element position/rotation/size (if present)
                if (this.svgEl && this.svgEl.parentNode) {
                    // Canvas and container may be scaled; position relative to container
                    const container = document.getElementById('gameContainer');
                    // Ensure element size roughly matches missile.size
                    const w = this.size * 2;
                    const h = this.size * 2;
                    this.svgEl.style.width = w + 'px';
                    this.svgEl.style.height = h + 'px';
                    // Place centered over the missile's canvas coordinates (container is positioned)
                    this.svgEl.style.left = (this.x - w / 2) + 'px';
                    this.svgEl.style.top = (this.y - h / 2) + 'px';
                    const deg = this.rotation * 180 / Math.PI;
                    this.svgEl.style.transform = `rotate(${deg}deg)`;
                }
            }

            draw() {
                // If SVG overlay exists, skip canvas body drawing (SVG provides visual)
                if (this.svgEl && this.svgEl.parentNode) {
                    // canvas drawing intentionally omitted when using SVG overlay
                } else {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.rotation);
                    
                    // Make missile look more obviously dangerous (red aura + skull)
                    ctx.shadowBlur = 18;
                    ctx.shadowColor = 'rgba(255,40,40,0.8)';

                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
                    gradient.addColorStop(0, '#8B0000');
                    gradient.addColorStop(1, '#4B0000');
                    ctx.fillStyle = gradient;

                    // Body
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size, this.size * 0.7, 0, 0, Math.PI * 2);
                    ctx.fill();

                    // Dangerous wings/flames
                    ctx.fillStyle = 'rgba(255,80,0,0.9)';
                    ctx.beginPath();
                    ctx.ellipse(-this.size * 0.5, 0, this.size * 0.6, this.size * 0.3, -0.3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(this.size * 0.5, 0, this.size * 0.6, this.size * 0.3, 0.3, 0, Math.PI * 2);
                    ctx.fill();

                    // Missile marker simplified (no skull) - keep red aura and trail for danger

                    ctx.restore();
                }

                // Stronger trail particles to highlight danger
                if (frameCount % 2 === 0) {
                    particles.push(new Particle(this.x + 6, this.y, 'shatter'));
                }
            }

            cleanup() {
                try {
                    if (this.svgEl && this.svgEl.parentNode) this.svgEl.parentNode.removeChild(this.svgEl);
                } catch (e) {}
                this.svgEl = null;
            }

            isOffScreen() {
                return this.x + this.size < 0;
            }
        }

        class Collectible {
            constructor(type) {
                this.x = GW + Math.random() * 200;
                this.y = Math.random() * (GH - 200) + 100;
                this.type = type || ['scarab', 'ankh', 'gem', 'ring'][Math.floor(Math.random() * 4)];
                this.size = 12;
                this.rotation = 0;
                this.bobPhase = Math.random() * Math.PI * 2;
                this.collected = false;
                this.value = this.type === 'scarab' ? 10 : this.type === 'ankh' ? 15 : this.type === 'gem' ? 20 : 25;
            }

            update() {
                this.x -= scrollSpeed;
                this.rotation += 0.05;
                this.bobPhase += 0.1;
            }

            draw() {
                const bob = Math.sin(this.bobPhase) * 3;
                ctx.save();
                ctx.translate(this.x, this.y + bob);
                ctx.rotate(this.rotation);
                
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#FFD700';
                
                if (this.type === 'scarab') {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size, this.size * 0.7, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'ankh') {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, -4, 4, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, 10);
                    ctx.moveTo(-6, 3);
                    ctx.lineTo(6, 3);
                    ctx.stroke();
                } else if (this.type === 'gem') {
                    ctx.fillStyle = '#00FFFF';
                    ctx.beginPath();
                    ctx.moveTo(0, -this.size);
                    ctx.lineTo(this.size * 0.7, 0);
                    ctx.lineTo(0, this.size);
                    ctx.lineTo(-this.size * 0.7, 0);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 0.6, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.restore();
            }

            isOffScreen() {
                return this.x + this.size < 0;
            }
        }

        // Particle class
        class Particle {
            constructor(x, y, type = 'dust', customColor = null) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4 - 2;
                this.life = 1;
                this.size = Math.random() * 4 + 2;
                this.customColor = customColor;
                if (type === 'jetpack') {
                    this.color = customColor || (Math.random() > 0.5 ? '#00FFFF' : '#FFD700');
                    this.vy = Math.random() * 2 + 1;
                    this.vx = Math.random() * -2 - 1;
                    this.life = 0.8;
                } else if (type === 'jetTrail') {
                    // Longer, softer trail particle for throttle visualization
                    this.color = customColor || 'rgba(0,220,200,0.25)';
                    this.vx = - (2 + Math.random() * 1.5);
                    this.vy = (Math.random() - 0.5) * 0.6;
                    this.size = 6 + Math.random() * 6;
                    this.life = 1.2 + Math.random() * 0.8;
                } else if (type === 'streak') {
                    // long directional streak used for jetpack light rays
                    this.color = customColor || 'rgba(0,220,200,0.85)';
                    // streaks move quickly backwards relative to player
                    this.vx = -6 - Math.random() * 6;
                    this.vy = (Math.random() - 0.5) * 1.2;
                    // length of streak (used as drawing length)
                    this.length = 40 + Math.random() * 90;
                    this.size = 2 + Math.random() * 2; // thickness
                    this.life = 1.6 + Math.random() * 1.4;
                } else if (type === 'gold') {
                    this.color = customColor || '#FFD700';
                } else if (type === 'shatter') {
                    this.color = customColor || '#e6c08a';
                } else if (type === 'smoke') {
                    this.color = customColor || 'rgba(60,60,60,0.6)';
                    this.vx = (Math.random() - 0.5) * 1.5;
                    this.vy = - (Math.random() * 0.8 + 0.4);
                    this.size = Math.random() * 8 + 6;
                    this.life = 1.6 + Math.random() * 0.8;
                } else if (type === 'ember') {
                    this.color = customColor || '#ff6a00';
                } else {
                    this.color = customColor || '#d2a679';
                }
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                if (this.type === 'smoke') {
                    // slow rise and fade
                    this.x += this.vx * 0.8;
                    this.y += this.vy * 0.8;
                    this.life -= 0.008;
                    this.size *= 0.995;
                } else if (this.type === 'streak') {
                    // streaks behave like exhaust/smoke: move primarily along vy, slightly damp and wobble
                    // apply slight velocity damping so streaks hang a bit like smoke
                    this.vx *= 0.995;
                    this.vy *= 0.985;
                    // subtle sideways wobble
                    this.x += Math.sin(this.life * 10 + this.x * 0.01) * 0.35;
                    this.y += Math.cos(this.life * 8 + this.y * 0.01) * 0.12;
                    // fade and slightly shrink
                    this.life -= 0.028;
                    this.size *= 0.992;
                } else {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.vy += 0.2; // Gravity
                    this.life -= 0.02;
                    this.size *= 0.97;
                }
            }

            draw() {
                if (this.type === 'streak') {
                    // draw an elongated streak aligned with velocity
                    const angle = Math.atan2(this.vy, this.vx);
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(angle);
                    const len = this.length || 60;
                    const thickness = this.size || 3;
                    // gradient from bright color to transparent along the length
                    const g = ctx.createLinearGradient(0, 0, -len, 0);
                    try {
                        g.addColorStop(0, this.color);
                        g.addColorStop(0.6, this.color.replace('0.85', '0.45'));
                        g.addColorStop(1, 'rgba(0,0,0,0)');
                    } catch (e) {
                        g.addColorStop(0, this.color);
                        g.addColorStop(1, 'rgba(0,0,0,0)');
                    }
                    ctx.fillStyle = g;
                    ctx.globalAlpha = Math.max(0, Math.min(1, this.life));
                    ctx.beginPath();
                    ctx.rect(-len, -thickness / 2, len, thickness);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    ctx.restore();
                } else {
                    ctx.fillStyle = this.color;
                    ctx.globalAlpha = this.life;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            }

            isDead() {
                return this.life <= 0;
            }
        }

        // Debris pieces created when obstacles are blown up by shield
        class Debris {
            constructor(x, y, color, kind, lightColor) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 6;
                this.vy = (Math.random() - 1.5) * 6;
                this.size = Math.random() * 12 + 6;
                this.rotation = Math.random() * Math.PI * 2;
                this.vr = (Math.random() - 0.5) * 0.25;
                this.life = 220 + Math.random() * 240;
                this.color = color || '#8B5A2B';
                this.kind = kind || 'rock';
                this.emitsLight = !!lightColor;
                this.lightColor = lightColor || null;
                this.hasLanded = false;
            }

            update() {
                this.vy += 0.45; // gravity
                this.x += this.vx;
                this.y += this.vy;
                this.rotation += this.vr;
                this.life -= 2;

                const groundY = GH - 80;
                if (this.y > groundY) {
                    // create decal on first contact
                    if (!this.hasLanded) {
                        this.hasLanded = true;
                        // only some fragments leave a decal to avoid heavy overlapping smog
                        if (Math.random() < 0.35) {
                            const decalColor = (this.kind === 'metal') ? 'rgba(60,40,10,0.28)' : 'rgba(40,30,30,0.22)';
                            decals.push(new Decal(this.x, groundY - 6, decalColor, 18 + Math.random()*36));
                        }
                    }
                    this.y = groundY;
                    this.vy *= -0.25 - Math.random()*0.1;
                    this.vx *= 0.5;
                    this.life -= 12;
                }
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                // fade based on remaining life
                const alpha = Math.max(0, Math.min(1, this.life / 220));
                ctx.globalAlpha = alpha;

                if (this.kind === 'metal') {
                    // metallic shard
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-this.size / 2, -this.size / 3, this.size, this.size * 0.6);
                    ctx.strokeStyle = 'rgba(255,255,255,0.18)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(-this.size / 2, -this.size / 6);
                    ctx.lineTo(this.size / 2, -this.size / 6);
                    ctx.stroke();
                } else if (this.kind === 'obelisk') {
                    // obelisk fragment: taller shard
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-this.size * 0.2, -this.size, this.size * 0.4, this.size * 1.6);
                    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(-this.size * 0.2, -this.size, this.size * 0.4, this.size * 1.6);
                } else {
                    // rock fragment
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.size * 0.6, this.size * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillRect(-this.size * 0.35, this.size * 0.1, this.size * 0.7, this.size * 0.35);
                }

                ctx.globalAlpha = 1;
                ctx.restore();

                // soft light emission for glowing fragments
                if (this.emitsLight && this.lightColor) {
                    try {
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        const glowRad = this.size * 3;
                        const g = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowRad);
                        g.addColorStop(0, this.lightColor);
                        g.addColorStop(1, 'rgba(0,0,0,0)');
                        ctx.fillStyle = g;
                        ctx.fillRect(this.x - glowRad, this.y - glowRad, glowRad * 2, glowRad * 2);
                        ctx.restore();
                    } catch (e) {
                        // ignore drawing errors
                    }
                }
            }

            isDead() {
                return this.life <= 0;
            }
        }

        // Draw a simple skull icon on canvas (vector, consistent style)
        function drawSkull(ctx, x, y, size, fillStyle = 'rgba(255,240,240,0.95)') {
            ctx.save();
            ctx.translate(x, y);
            const s = size / 24; // base scale
            ctx.scale(s, s);

            // Head
            ctx.fillStyle = fillStyle;
            ctx.beginPath();
            ctx.arc(0, 0, 8, 0, Math.PI * 2);
            ctx.fill();

            // Eye sockets
            ctx.fillStyle = 'rgba(30,30,30,0.95)';
            ctx.beginPath(); ctx.ellipse(-3.2, -2, 1.8, 2.2, 0, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(3.2, -2, 1.8, 2.2, 0, 0, Math.PI * 2); ctx.fill();

            // Nasal cavity (small triangle)
            ctx.beginPath();
            ctx.moveTo(0, -0.5);
            ctx.lineTo(-1.6, 2.5);
            ctx.lineTo(1.6, 2.5);
            ctx.closePath();
            ctx.fill();

            // Jaw / teeth block
            ctx.fillStyle = fillStyle;
            ctx.beginPath();
            ctx.rect(-6, 5, 12, 5);
            ctx.fill();

            // Teeth separators
            ctx.strokeStyle = 'rgba(180,180,180,0.9)';
            ctx.lineWidth = 0.9;
            for (let tx = -4; tx <= 4; tx += 2) {
                ctx.beginPath();
                ctx.moveTo(tx, 5);
                ctx.lineTo(tx, 9);
                ctx.stroke();
            }

            ctx.restore();
        }

        // Ambient particle class
        class AmbientParticle {
            constructor() {
                this.x = Math.random() * GW;
                this.y = Math.random() * GH;
                this.size = Math.random() * 2 + 0.5;
                this.speedX = Math.random() * 0.5 + 0.2;
                this.speedY = (Math.random() - 0.5) * 0.3;
                this.opacity = Math.random() * 0.5 + 0.2;
            }

            update() {
                this.x -= this.speedX;
                this.y += this.speedY;

                if (this.x < 0) this.x = GW;
                if (this.y < 0) this.y = GH;
                if (this.y > GH) this.y = 0;
            }

            draw() {
                ctx.fillStyle = `rgba(244, 232, 208, ${this.opacity})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Initialize ambient particles
        function initAmbientParticles() {
            ambientParticles = [];
            for (let i = 0; i < 50; i++) {
                ambientParticles.push(new AmbientParticle());
            }
        }

        // Draw parallax background
        function drawBackground() {
            // Egyptian tomb walls - gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, GH);
            gradient.addColorStop(0, '#4a3829');
            gradient.addColorStop(0.5, '#3a2817');
            gradient.addColorStop(1, '#2c1810');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, GW, GH - 80);

            // Layer 1 - Far wall hieroglyphics
            const offset1 = backgroundOffset * 0.2;
            ctx.globalAlpha = 0.4;
            
            // Hieroglyphic panels
            for (let i = 0; i < 4; i++) {
                const x = (i * 250 - (offset1 % 1000));
                
                // Panel background
                ctx.fillStyle = '#5a4336';
                ctx.fillRect(x, 50, 200, 150);
                
                // Gold hieroglyphs
                ctx.fillStyle = '#D4AF37';
                ctx.fillRect(x + 20, 70, 15, 40);
                ctx.beginPath();
                ctx.arc(x + 60, 90, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillRect(x + 90, 70, 20, 20);
                ctx.beginPath();
                ctx.arc(x + 140, 100, 15, 0, Math.PI * 2);
                ctx.fill();
                
                // Blue accents
                ctx.fillStyle = '#1E3A8A';
                ctx.fillRect(x + 30, 120, 25, 15);
                ctx.fillRect(x + 100, 130, 30, 12);
                
                // Red symbols
                ctx.fillStyle = '#DC143C';
                ctx.beginPath();
                ctx.arc(x + 170, 80, 8, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillRect(x + 150, 120, 15, 25);
            }
            
            ctx.globalAlpha = 1;

            // Layer 2 - Mid columns
            const offset2 = backgroundOffset * 0.5;
            ctx.fillStyle = 'rgba(139, 133, 137, 0.3)';
            for (let i = 0; i < 3; i++) {
                const x = (i * 300 - (offset2 % 900));
                ctx.fillRect(x, 0, 40, GH - 80);
                
                // Column decorations
                ctx.fillStyle = 'rgba(212, 175, 55, 0.4)';
                ctx.fillRect(x + 5, 100, 30, 5);
                ctx.fillRect(x + 5, 200, 30, 5);
                ctx.fillRect(x + 5, 300, 30, 5);
            }

            // Golden glow effect
            ctx.globalAlpha = 0.1;
            const glowGradient = ctx.createRadialGradient(GW / 2, GH / 2, 0, GW / 2, GH / 2, GW);
            glowGradient.addColorStop(0, '#FFD700');
            glowGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = glowGradient;
            ctx.fillRect(0, 0, GW, GH - 80);
            ctx.globalAlpha = 1;
        }

        // Draw ground (tomb floor)
        function drawGround() {
            const groundY = GH - 80;
            
            // Layered earth
            const gradient = ctx.createLinearGradient(0, groundY, 0, GH);
            gradient.addColorStop(0, '#8B7355');
            gradient.addColorStop(0.3, '#654321');
            gradient.addColorStop(1, '#4a3020');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, groundY, GW, 80);

            // Stratification lines
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 1; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(0, groundY + i * 20);
                ctx.lineTo(GW, groundY + i * 20);
                ctx.stroke();
            }

            // Archaeological elements
            ctx.fillStyle = '#a0826d';
            const offset = backgroundOffset * 0.8;
            for (let i = 0; i < 5; i++) {
                const x = (i * 100 - (offset % 500)) % GW;
                // Pottery shard
                ctx.save();
                ctx.translate(x + 20, groundY + 30);
                ctx.rotate(Math.PI / 6);
                ctx.fillRect(0, 0, 15, 8);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.strokeRect(0, 0, 15, 8);
                ctx.restore();
            }

            // Small rocks
            ctx.fillStyle = '#696969';
            for (let i = 0; i < 8; i++) {
                const x = (i * 60 + 30 - (offset % 480)) % GW;
                ctx.beginPath();
                ctx.arc(x, groundY + 15, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw HUD
        function drawHUD() {
            // Distance
            ctx.fillStyle = 'rgba(244, 232, 208, 0.95)';
            ctx.font = 'bold 24px ' + getComputedStyle(document.body).fontFamily;
            ctx.textAlign = 'left';
            ctx.fillText(Math.floor(distance) + 'm', 20, 40);
            
            ctx.font = '12px ' + getComputedStyle(document.body).fontFamily;
            ctx.fillStyle = 'rgba(210, 166, 121, 0.9)';
            ctx.fillText('DISTANCE', 20, 55);
            
            // Treasures with golden scarab icon
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold 20px ' + getComputedStyle(document.body).fontFamily;
            ctx.textAlign = 'right';
            ctx.fillText('‚ú¶ ' + treasures, GW - 20, 40);
            
            ctx.font = '11px ' + getComputedStyle(document.body).fontFamily;
            ctx.fillStyle = 'rgba(210, 166, 121, 0.9)';
            ctx.fillText('TREASURES', GW - 20, 55);
            
            // Total saved treasures (from previous runs) - displayed under current treasures
            try {
                const saved = loadProgress();
                ctx.font = '11px ' + getComputedStyle(document.body).fontFamily;
                ctx.fillStyle = 'rgba(212, 175, 55, 0.95)';
                ctx.textAlign = 'right';
                ctx.fillText('TOTAL: ' + (saved.total || 0), GW - 20, 72);
            } catch (e) {
                // ignore drawing errors
            }
            
            // Active powerup indicators (support multiple)
            const activeKeys = Object.keys(activePowerups);
            if (activeKeys.length > 0) {
                const powerupY = 70;
                const boxW = 160;
                ctx.fillStyle = 'rgba(42, 30, 20, 0.7)';
                ctx.fillRect(GW / 2 - boxW/2, powerupY - 28, boxW, 40 + activeKeys.length * 18);
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.strokeRect(GW / 2 - boxW/2, powerupY - 28, boxW, 40 + activeKeys.length * 18);

                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 12px ' + getComputedStyle(document.body).fontFamily;
                ctx.textAlign = 'left';
                let py = powerupY - 8;
                const padX = GW / 2 - boxW/2 + 10;
                for (const t of activeKeys) {
                    const remaining = activePowerups[t];
                    const dur = powerupDurations[t] || 360;
                    const progress = Math.max(0, Math.min(1, remaining / dur));

                    ctx.fillStyle = '#FFD700';
                    ctx.fillText(t.toUpperCase(), padX, py);

                    // draw small progress bar
                    const barW = 90;
                    ctx.fillStyle = 'rgba(212,175,55,0.25)';
                    ctx.fillRect(padX + 70, py - 10, barW, 8);
                    ctx.fillStyle = '#FFD700';
                    ctx.fillRect(padX + 70, py - 10, barW * progress, 8);

                    py += 18;
                }
            }
        }

        // Create shatter effect
        function createShatterEffect() {
            // Use player position for shatter if available, otherwise center of canvas
            const cx = (player && typeof player.x === 'number') ? player.x : GW / 2;
            const cy = (player && typeof player.y === 'number') ? player.y : GH / 2;
            const spread = (player && player.size) ? player.size : 30;
            for (let i = 0; i < 24; i++) {
                particles.push(new Particle(
                    cx + (Math.random() - 0.5) * spread,
                    cy + (Math.random() - 0.5) * spread,
                    'shatter'
                ));
            }
        }

        // --- Persistent progress (localStorage) ---
        function loadProgress() {
            const total = parseInt(localStorage.getItem('tombRunner_totalTreasures') || '0', 10);
            const best = parseInt(localStorage.getItem('tombRunner_bestDistance') || '0', 10);
            return { total, best };
        }

        // --- Character store data & helpers ---
        const characters = [
            { id: 'classic', name: 'Classic Explorer', run: 'characterrun.svg', fly: 'characterfly.svg', price: 0 },
            { id: 'azure', name: 'Azure Scout', run: 'bluerun.svg', fly: 'bluefly.svg', price: 1000 },
            { id: 'jungle', name: 'Jungle Veteran', run: 'junglevetrun.svg', fly: 'junglevetfly.svg', price: 5000 },
            { id: 'mystic', name: 'Mystic', run: 'mysticrun.svg', fly: 'mysticfly.svg', price: 8000 },
            { id: 'imperial', name: 'Imperial', run: 'imperialrun.svg', fly: 'imperialfly.svg', price: 10000 }
        ];

        // Image cache used to preload common SVG assets (characters, enemies)
        const imageCache = Object.create(null);

        function preloadImages() {
            const urls = new Set();
            // gather character run/fly urls
            for (const c of characters) {
                if (c.run) urls.add(c.run);
                if (c.fly) urls.add(c.fly);
            }
            // common enemy / misc svgs used as overlays
            urls.add('svgfile.svg');

            for (const u of urls) {
                try {
                    const img = new Image();
                    img.src = u;
                    imageCache[u] = img;
                    // start decoding where supported to warm cache
                    if (img.decode) img.decode().catch(() => {});
                } catch (e) {
                    // ignore preload errors
                }
            }
        }

        // Kick off preloading early
        try { preloadImages(); } catch (e) {}

        function getUnlockedChars() {
            try {
                const raw = localStorage.getItem('tombRunner_unlockedChars');
                if (!raw) return ['classic'];
                return JSON.parse(raw);
            } catch (e) { return ['classic']; }
        }

        function saveUnlockedChars(list) {
            localStorage.setItem('tombRunner_unlockedChars', JSON.stringify(list));
        }

        function getSelectedChar() {
            return localStorage.getItem('tombRunner_selectedChar') || 'classic';
        }

        function setSelectedChar(id) {
            localStorage.setItem('tombRunner_selectedChar', id);
            updateStartScreenProgress();
        }

        function getSavedTotal() {
            return parseInt(localStorage.getItem('tombRunner_totalTreasures') || '0', 10);
        }

        function setSavedTotal(n) {
            localStorage.setItem('tombRunner_totalTreasures', String(Math.max(0, Math.floor(n))));
            updateStartScreenProgress();
            updateGameOverProgress();
        }

        function purchaseCharacter(id) {
            const ch = characters.find(c => c.id === id);
            if (!ch) return false;
            const unlocked = getUnlockedChars();
            if (unlocked.includes(id)) return true;
            const saved = getSavedTotal();
            if (saved < ch.price) {
                alert('Not enough saved treasures to buy ' + ch.name + '.');
                return false;
            }
            setSavedTotal(saved - ch.price);
            unlocked.push(id);
            saveUnlockedChars(unlocked);
            renderStore();
            return true;
        }

        function openStore() {
            document.getElementById('storeScreen').classList.remove('hidden');
            renderStore();
        }

        function closeStore() {
            document.getElementById('storeScreen').classList.add('hidden');
        }

        function renderStore() {
            const listEl = document.getElementById('storeList');
            listEl.innerHTML = '';
            const unlocked = getUnlockedChars();
            const selected = getSelectedChar();
            const saved = getSavedTotal();
            for (const c of characters) {
                const card = document.createElement('div');
                card.className = 'store-card';

                const img = document.createElement('img');
                // show flying preview as thumbnail
                img.src = c.fly;
                card.appendChild(img);

                const meta = document.createElement('div');
                meta.className = 'meta';
                const title = document.createElement('div');
                title.className = 'title';
                title.textContent = c.name;
                meta.appendChild(title);
                const price = document.createElement('div');
                price.className = 'price';
                price.textContent = c.price > 0 ? (c.price + ' treasures') : 'Included';
                meta.appendChild(price);
                card.appendChild(meta);

                const actions = document.createElement('div');
                if (unlocked.includes(c.id)) {
                    if (selected === c.id) {
                        const btn = document.createElement('button'); btn.textContent = 'Selected'; btn.disabled = true; actions.appendChild(btn);
                    } else {
                        const btn = document.createElement('button'); btn.textContent = 'Select'; btn.onclick = () => { setSelectedChar(c.id); renderStore(); }; actions.appendChild(btn);
                    }
                } else {
                    const btn = document.createElement('button'); btn.textContent = 'Buy';
                    btn.onclick = () => {
                        if (purchaseCharacter(c.id)) {
                            alert('Purchased ' + c.name + '!');
                        }
                    };
                    // disable if not enough saved treasures
                    if (saved < c.price) btn.disabled = true;
                    actions.appendChild(btn);
                }

                card.appendChild(actions);
                listEl.appendChild(card);
            }
        }

        function saveProgressAdd(treasuresGained, distanceTraveled) {
            // Deprecated: kept for backward compatibility. Use addToSavedTotal and saveBestDistance instead.
            const prevTotal = parseInt(localStorage.getItem('tombRunner_totalTreasures') || '0', 10);
            const prevBest = parseInt(localStorage.getItem('tombRunner_bestDistance') || '0', 10);
            const newTotal = prevTotal + (treasuresGained || 0);
            const newBest = Math.max(prevBest, Math.floor(distanceTraveled || 0));
            localStorage.setItem('tombRunner_totalTreasures', String(newTotal));
            localStorage.setItem('tombRunner_bestDistance', String(newBest));
            updateStartScreenProgress();
            updateGameOverProgress();
            return { newTotal, newBest };
        }

        function addToSavedTotal(amount) {
            if (!amount || amount <= 0) return parseInt(localStorage.getItem('tombRunner_totalTreasures') || '0', 10);
            const prev = parseInt(localStorage.getItem('tombRunner_totalTreasures') || '0', 10);
            const next = prev + amount;
            localStorage.setItem('tombRunner_totalTreasures', String(next));
            updateStartScreenProgress();
            updateGameOverProgress();
            return next;
        }

        function saveBestDistance(distanceTraveled) {
            const dist = Math.floor(distanceTraveled || 0);
            const prevBest = parseInt(localStorage.getItem('tombRunner_bestDistance') || '0', 10);
            if (dist > prevBest) {
                localStorage.setItem('tombRunner_bestDistance', String(dist));
                updateStartScreenProgress();
                updateGameOverProgress();
            }
            return Math.max(prevBest, dist);
        }

        // Autosave: periodically persist current run distance and best distance
        let autosaveInterval = null;
        function autosave() {
            try {
                localStorage.setItem('tombRunner_autosave_distance', String(Math.floor(distance)));
                localStorage.setItem('tombRunner_autosave_currentRunTreasures', String(treasures));
                // ensure best distance is up to date
                saveBestDistance(Math.floor(distance));
            } catch (e) {
                // ignore quota errors
            }
        }

        // Powerup activation helpers
        let speedBoostApplied = false;
        const powerupDurations = {
            shield: 600,
            magnet: 480,
            speed: 360
        };

        function activatePowerup(type) {
            // Add or refresh duration for this powerup type
            activePowerups[type] = powerupDurations[type] || 360;

            // Visual burst
            for (let j = 0; j < 15; j++) {
                particles.push(new Particle(player.x + 10, player.y, 'gold'));
            }

            // Apply immediate effects for speed (only once)
            if (type === 'speed' && !speedBoostApplied) {
                const boost = 3; // add to scroll speed
                scrollSpeed += boost;
                speedBoostApplied = true;
            }
        }

        function deactivatePowerup(type) {
            // Remove effect for a specific powerup type
            if (!type) return;
            if (type === 'speed' && speedBoostApplied) {
                const boost = 3;
                scrollSpeed = Math.max(config.scrollSpeed, scrollSpeed - boost);
                speedBoostApplied = false;
            }
            delete activePowerups[type];
        }

        function resetProgress() {
            localStorage.removeItem('tombRunner_totalTreasures');
            localStorage.removeItem('tombRunner_bestDistance');
            updateStartScreenProgress();
            updateGameOverProgress();
            alert('Progress reset.');
        }

        function updateStartScreenProgress() {
            const p = loadProgress();
            const savedTreasuresEl = document.getElementById('savedTreasuresDisplay');
            const savedBestEl = document.getElementById('savedBestDisplay');
            if (savedTreasuresEl) savedTreasuresEl.textContent = 'Saved Treasures: ' + p.total;
            if (savedBestEl) savedBestEl.textContent = 'Best: ' + p.best + 'm';
        }

        function updateGameOverProgress() {
            const p = loadProgress();
            const savedTotalEl = document.getElementById('savedTotalDisplay');
            const savedBestEl = document.getElementById('savedBestDisplayGameover');
            if (savedTotalEl) savedTotalEl.textContent = 'Total Saved: ' + p.total;
            if (savedBestEl) savedBestEl.textContent = 'Best: ' + p.best + 'm';
        }

        // Initialize game
        function initGame() {
            // remove any leftover svg overlays from previous runs
            try {
                const olds = document.querySelectorAll('.enemy-svg, .player-svg');
                olds.forEach(n => n.parentNode && n.parentNode.removeChild(n));
            } catch (e) {}

            player = new Player();
            obstacles = [];
            collectibles = [];
            powerups = [];
            particles = [];
            distance = 0;
            treasures = 0;
            frameCount = 0;
            scrollSpeed = config.scrollSpeed;
            backgroundOffset = 0;
            isHoldingJetpack = false;
            activePowerup = null;
            powerupTimer = 0;
            initAmbientParticles();
            debris = [];
            decals = [];
            // start autosave interval (clear existing first)
            if (autosaveInterval) clearInterval(autosaveInterval);
            autosaveInterval = setInterval(autosave, 5000);
        }

        // Start game
        function startGame() {
            // If a pending gameOver UI is scheduled, cancel it so the restart is clean
            try {
                if (gameOverTimerId) {
                    clearTimeout(gameOverTimerId);
                    gameOverTimerId = null;
                }
            } catch (e) {
                // gameOverTimerId may not be initialized yet in some environments; ignore.
            }

            overlayInteractive = false;
            gameState = 'playing';
            initGame();
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
        }

        // Restart game
        function restartGame() {
            // Ensure no delayed gameOver UI will trigger after restart
            try {
                if (gameOverTimerId) {
                    clearTimeout(gameOverTimerId);
                    gameOverTimerId = null;
                }
            } catch (e) {}
            // only allow restart if overlay is interactive (visible) or called by button
            // (buttons call restartGame directly, so allow them too)
            startGame();
        }

        // Game over
        function gameOver() {
            gameState = 'gameover';
            createShatterEffect();
            
            // Clear any previous timer then schedule the UI/show logic ‚Äî keep a handle so it can be cancelled
            if (gameOverTimerId) {
                clearTimeout(gameOverTimerId);
                gameOverTimerId = null;
            }

            gameOverTimerId = setTimeout(() => {
                // Save best distance (treasures are accumulated live when collected)
                const savedBest = saveBestDistance(Math.floor(distance));

                document.getElementById('finalScore').textContent = Math.floor(distance);
                document.getElementById('treasureScore').textContent = treasures;
                
                const medalContainer = document.getElementById('medalContainer');
                medalContainer.innerHTML = '';
                if (distance >= 5000) {
                    medalContainer.innerHTML = '<div class="medal gold">üè∫</div><p style="color: #FFD700; margin-top: 10px; font-weight: 600; font-size: 16px;">GOLDEN PHARAOH</p><p style="color: #d2a679; font-size: 13px; margin-top: 5px;">Master of the Tombs!</p>';
                } else if (distance >= 3000) {
                    medalContainer.innerHTML = '<div class="medal silver">‚öîÔ∏è</div><p style="color: #C0C0C0; margin-top: 10px; font-weight: 600; font-size: 16px;">SILVER ANKH</p><p style="color: #d2a679; font-size: 13px; margin-top: 5px;">Skilled Archaeologist</p>';
                } else if (distance >= 1000) {
                    medalContainer.innerHTML = '<div class="medal bronze">üêû</div><p style="color: #CD7F32; margin-top: 10px; font-weight: 600; font-size: 16px;">BRONZE SCARAB</p><p style="color: #d2a679; font-size: 13px; margin-top: 5px;">Brave Explorer</p>';
                } else {
                    medalContainer.innerHTML = '<p style="color: #d2a679; font-size: 14px; margin-top: 10px;">Keep exploring to earn a rank!</p>';
                }

                // Update saved progress UI
                updateStartScreenProgress();
                updateGameOverProgress();
                
                // Show overlay and mark it interactive (allow input to restart now)
                gameOverScreen.classList.remove('hidden');
                overlayInteractive = true;

                // clear the timer id because the callback has run
                gameOverTimerId = null;
                // transition into final gameover state
                gameState = 'gameover';
            }, 500);
        }

        // Spawning functions
        function spawnObstacle() {
            const rand = Math.random();
            if (rand < 0.5) {
                obstacles.push(new Zapper());
            } else if (rand < 0.8) {
                obstacles.push(new Laser());
            } else {
                obstacles.push(new Missile(player ? player.y : GH / 2));
            }
        }

        function spawnCollectibles() {
            const count = Math.floor(Math.random() * 3) + 2;
            for (let i = 0; i < count; i++) {
                collectibles.push(new Collectible());
            }
        }

        function spawnPowerup() {
            const types = ['shield', 'magnet', 'speed'];
            const type = types[Math.floor(Math.random() * types.length)];
            powerups.push({
                x: GW + 100,
                y: Math.random() * (GH - 200) + 100,
                type: type,
                size: 20,
                rotation: 0
            });
        }

        // Update game
        function update() {
            if (gameState !== 'playing') return;

            frameCount++;
            distance += scrollSpeed / 60;
            backgroundOffset += scrollSpeed;

            // Gradually increase speed
            if (scrollSpeed < config.scrollSpeedMax) {
                scrollSpeed += config.scrollAcceleration;
            }

            // Update player
            player.jetpackActive = isHoldingJetpack;
            player.update();

            // Spawn obstacles
            if (frameCount % 120 === 0) {
                spawnObstacle();
            }

            // Spawn collectibles
            if (frameCount % 80 === 0) {
                spawnCollectibles();
            }

            // Spawn powerups
            if (frameCount % 600 === 0) {
                spawnPowerup();
            }

            // Update obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                obstacles[i].update();

                // Check collision.
                if (player.checkCollision(obstacles[i])) {
                    if (activePowerups['shield']) {
                        // Explode / destroy obstacle instead of killing player
                        explodeObstacle(obstacles[i]);
                        try { if (obstacles[i] && typeof obstacles[i].cleanup === 'function') obstacles[i].cleanup(); } catch (e) {}
                        obstacles.splice(i, 1);
                        continue;
                    } else {
                        gameOver();
                        return;
                    }
                }

                // Score distance
                if (!obstacles[i].scored && obstacles[i].x + 50 < player.x) {
                    obstacles[i].scored = true;
                }

                if (obstacles[i].isOffScreen()) {
                    try { if (obstacles[i] && typeof obstacles[i].cleanup === 'function') obstacles[i].cleanup(); } catch (e) {}
                    obstacles.splice(i, 1);
                }
            }

            // Update collectibles
            for (let i = collectibles.length - 1; i >= 0; i--) {
                collectibles[i].update();

                // Check collection
                const magnetRange = activePowerups['magnet'] ? 100 : 0;
                if (!collectibles[i].collected) {
                    if (player.checkCollectible(collectibles[i]) || 
                        (magnetRange > 0 && Math.abs(player.x - collectibles[i].x) < magnetRange && Math.abs(player.y - collectibles[i].y) < magnetRange)) {
                        collectibles[i].collected = true;
                            treasures++;
                            // Immediately add to cumulative saved total so progress is preserved if player leaves mid-run
                            addToSavedTotal(collectibles[i].value || 1);
                        // Sparkle effect
                        for (let j = 0; j < 8; j++) {
                            particles.push(new Particle(collectibles[i].x, collectibles[i].y, 'gold'));
                        }
                    }
                }

                if (collectibles[i].isOffScreen() || collectibles[i].collected) {
                    collectibles.splice(i, 1);
                }
            }

                // Update powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                powerups[i].x -= scrollSpeed;
                powerups[i].rotation += 0.05;

                // Check collection
                const dx = player.x - powerups[i].x;
                const dy = player.y - powerups[i].y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < player.size / 2 + powerups[i].size) {
                    // Use activatePowerup helper for consistent behavior
                    activatePowerup(powerups[i].type);
                    powerups.splice(i, 1);
                } else if (powerups[i].x < -50) {
                    powerups.splice(i, 1);
                }
            }

            // Update active powerups timers
            for (const type in activePowerups) {
                if (!Object.prototype.hasOwnProperty.call(activePowerups, type)) continue;
                activePowerups[type]--;
                if (activePowerups[type] <= 0) {
                    deactivatePowerup(type);
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                if (particles[i].isDead()) {
                    particles.splice(i, 1);
                }
            }

            // Update debris
            for (let i = debris.length - 1; i >= 0; i--) {
                debris[i].update();
                if (debris[i].isDead()) debris.splice(i, 1);
            }

            // Update ambient particles
            ambientParticles.forEach(p => p.update());

            // Update screen shake/flash
            if (screenShakeTimer > 0) {
                screenShakeTimer--;
                if (screenShakeTimer <= 0) screenShake = 0;
            }
            if (flashAlpha > 0) {
                // faster fade so the flash doesn't linger ‚Äî controlled by flashDecay
                flashAlpha -= flashDecay;
                if (flashAlpha < 0) flashAlpha = 0;
            }
        }

        // Draw powerup
        function drawPowerup(powerup) {
            ctx.save();
            ctx.translate(powerup.x, powerup.y);
            ctx.rotate(powerup.rotation);
            
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#FFD700';
            
            // Background glow
            ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
            ctx.beginPath();
            ctx.arc(0, 0, powerup.size + 5, 0, Math.PI * 2);
            ctx.fill();
            
            if (powerup.type === 'shield') {
                // Shield - golden sarcophagus
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(0, 0, powerup.size - 5, 0, Math.PI * 2);
                ctx.stroke();
                ctx.strokeStyle = '#00FFFF';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, powerup.size - 8, 0, Math.PI * 2);
                ctx.stroke();
            } else if (powerup.type === 'magnet') {
                // Magnet - scarab
                ctx.fillStyle = '#FFD700';
                ctx.beginPath();
                ctx.ellipse(0, 0, powerup.size - 5, powerup.size - 8, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 2;
                ctx.stroke();
            } else if (powerup.type === 'speed') {
                // Speed - winged sandals
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(-powerup.size / 2, -5, powerup.size, 10);
                // Wings
                ctx.beginPath();
                ctx.moveTo(-powerup.size / 2, 0);
                ctx.lineTo(-powerup.size, -10);
                ctx.lineTo(-powerup.size / 2, 5);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(powerup.size / 2, 0);
                ctx.lineTo(powerup.size, -10);
                ctx.lineTo(powerup.size / 2, 5);
                ctx.closePath();
                ctx.fill();
            }
            
            ctx.restore();
        }

        // Explode an obstacle with particles and debris when shield collides
        function explodeObstacle(ob) {
            let cx = GW / 2;
            let cy = GH / 2;
            // determine center based on obstacle type
            if (ob.type === 'zapper') {
                cx = ob.x + ob.width / 2;
                cy = ob.gapY + ob.gap / 2;
            } else if (ob.type === 'laser') {
                cx = ob.x + Math.cos(ob.rotation) * ob.length * 0.5;
                cy = ob.y + Math.sin(ob.rotation) * ob.length * 0.5;
            } else if (ob.type === 'missile') {
                cx = ob.x;
                cy = ob.y;
            }

            // Big burst of bright particles
            // Choose palettes depending on obstacle type to make fragments match the object
            let fragPalette = ['#e6c08a'];
            let emberPalette = ['#ff6a00'];
            let debrisLight = null;
            if (ob.type === 'zapper') {
                fragPalette = ['#8B8589', '#A0A0A0', '#696969', '#D4AF37'];
                emberPalette = ['#BFA58A'];
                debrisLight = null;
            } else if (ob.type === 'laser') {
                fragPalette = ['#2b2b2b', '#4b2b00', '#ff6a00', '#ffb27a'];
                emberPalette = ['#ff6a00', '#ffb27a'];
                debrisLight = 'rgba(255,120,60,0.18)';
            } else if (ob.type === 'missile') {
                fragPalette = ['#FFD700', '#B8860B', '#556B2F', '#00FFFF'];
                emberPalette = ['#FFD700', '#B8860B'];
                debrisLight = 'rgba(255,215,80,0.12)';
            } else {
                fragPalette = ['#6B4A2A', '#5A3E2A', '#7B5A43'];
                emberPalette = ['#8B5A2B'];
                debrisLight = null;
            }

            // Big burst of bright shatter particles (colors sampled from object palette)
            for (let i = 0; i < 40; i++) {
                const col = fragPalette[Math.floor(Math.random() * fragPalette.length)];
                const p = new Particle(cx + (Math.random() - 0.5) * 40, cy + (Math.random() - 0.5) * 40, 'shatter', col);
                p.vx += (Math.random() - 0.5) * 8;
                p.vy += (Math.random() - 0.5) * 8 - 2;
                particles.push(p);
            }

            // smoke and dust cloud
            for (let i = 0; i < 18; i++) {
                particles.push(new Particle(cx + (Math.random() - 0.5) * 60, cy + (Math.random() - 0.5) * 20, 'smoke'));
            }

            // Debris pieces that fall (exact color match with slight variation)
            let debrisCount = 12 + Math.floor(Math.random() * 12);
            // increase wall fragments for obelisks (zapper) and lasers for more visual impact
            if (ob.type === 'zapper') {
                debrisCount = 24 + Math.floor(Math.random() * 16);
            } else if (ob.type === 'laser') {
                debrisCount = 18 + Math.floor(Math.random() * 12);
            } else if (ob.type === 'missile') {
                debrisCount = 14 + Math.floor(Math.random() * 10);
            }
            for (let i = 0; i < debrisCount; i++) {
                let baseColor = '#6B4A2A';
                let kind = 'rock';
                let lightCol = debrisLight;
                if (ob.type === 'zapper') {
                    const stoneColors = ['#8B8589', '#A0A0A0', '#696969'];
                    baseColor = stoneColors[Math.floor(Math.random() * stoneColors.length)];
                    // small chance of gold fleck color
                    if (Math.random() < 0.12) baseColor = '#D4AF37';
                    kind = 'obelisk';
                } else if (ob.type === 'laser') {
                    const emberColors = ['#2b2b2b', '#4b2b00', '#ff6a00', '#ffb27a'];
                    baseColor = emberColors[Math.floor(Math.random() * emberColors.length)];
                    kind = 'rock';
                    lightCol = 'rgba(255,120,60,0.18)';
                } else if (ob.type === 'missile') {
                    const metalColors = ['#FFD700', '#B8860B', '#556B2F', '#00FFFF'];
                    baseColor = metalColors[Math.floor(Math.random() * metalColors.length)];
                    kind = 'metal';
                    lightCol = 'rgba(255,215,80,0.12)';
                } else {
                    const earthy = ['#6B4A2A', '#5A3E2A', '#7B5A43'];
                    baseColor = earthy[Math.floor(Math.random() * earthy.length)];
                    kind = 'rock';
                }

                // slight variation to the base color (darken/lighten a bit)
                function varyColor(hex) {
                    try {
                        const num = parseInt(hex.replace('#',''), 16);
                        let r = (num >> 16) & 0xFF;
                        let g = (num >> 8) & 0xFF;
                        let b = num & 0xFF;
                        const factor = 0.9 + Math.random() * 0.2; // vary by +-10%
                        r = Math.max(0, Math.min(255, Math.round(r * factor)));
                        g = Math.max(0, Math.min(255, Math.round(g * factor)));
                        b = Math.max(0, Math.min(255, Math.round(b * factor)));
                        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
                    } catch (e) {
                        return hex;
                    }
                }

                const colorVar = varyColor(baseColor);
                debris.push(new Debris(cx + (Math.random() - 0.5) * 60, cy + (Math.random() - 0.5) * 60, colorVar, kind, lightCol));
            }

            // ground-shock ripple: spawn small dust particles along ground below explosion
            const groundY = GH - 80;
            for (let i = 0; i < 18; i++) {
                const dx = cx + (Math.random() - 0.5) * 140;
                const dust = new Particle(dx, groundY - 6, 'shatter');
                dust.vx *= 0.7;
                dust.vy = -(Math.random() * 2 + 1);
                particles.push(dust);
            }

            // camera shake + flash (shorter, snappier flash)
            screenShake = 12;
            screenShakeTimer = 28;
            // make flash immediate and decay quickly so it's only visible in the moment
            flashAlpha = 1.0;
        }

        // Draw game
        function draw() {
            ctx.clearRect(0, 0, GW, GH);

            // Apply screen shake by translating the whole scene
            ctx.save();
            if (screenShakeTimer > 0 && screenShake > 0) {
                const sx = (Math.random() - 0.5) * screenShake;
                const sy = (Math.random() - 0.5) * screenShake;
                ctx.translate(sx, sy);
            }

            drawBackground();
            ambientParticles.forEach(p => p.draw());
            drawGround();

            // Draw decals on the ground (scorch/dust) under debris
            for (let i = decals.length - 1; i >= 0; i--) {
                if (decals[i].life <= 0) decals.splice(i, 1);
                else decals[i].draw();
            }

            // Draw debris (rubble) under obstacles/particles so it looks grounded
            debris.forEach(d => d.draw());

            // Draw collectibles
            collectibles.forEach(c => {
                if (!c.collected) c.draw();
            });

            // Draw powerups
            powerups.forEach(p => drawPowerup(p));

            // Draw obstacles
            obstacles.forEach(o => o.draw());

            // Draw streak particles behind the player so the lines appear *behind*
            for (let i = 0; i < particles.length; i++) {
                if (particles[i].type === 'streak') particles[i].draw();
            }

            // Draw player with shield effect if shield active
            if (gameState === 'playing') {
                if (activePowerups['shield']) {
                    ctx.save();
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00FFFF';
                    ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.size + 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, player.size + 15, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                player.draw();
            }

            // Draw remaining particles (non-streaks) so they render over the player where intended
            for (let i = 0; i < particles.length; i++) {
                if (particles[i].type !== 'streak') particles[i].draw();
            }

            // Flash overlay (white) to emphasize explosion ‚Äî drawn here to avoid blend-mode leakage
            if (flashAlpha > 0) {
                ctx.save();
                ctx.globalAlpha = Math.min(1, flashAlpha);
                ctx.fillStyle = '#fff';
                ctx.fillRect(0, 0, GW, GH);
                ctx.restore();
            }

            if (gameState === 'playing') {
                drawHUD();
            }

            // restore the canvas state pushed at the start of draw() (screen shake, transforms)
            ctx.restore();
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Input handling - Hold to fly
        // Use Pointer Events for unified mouse/touch/pen handling and prevent scrolling on touch devices
        canvas.addEventListener('pointerdown', (e) => {
            // ignore right-click / secondary buttons
            if (e.button && e.button !== 0) return;
            e.preventDefault();
            if (gameState === 'playing') {
                isHoldingJetpack = true;
                // capture pointer so we still get pointerup outside the canvas
                try { canvas.setPointerCapture && canvas.setPointerCapture(e.pointerId); } catch (err) {}
            } else if (gameState === 'gameover') {
                restartGame();
            } else if (gameState === 'start') {
                // allow starting by tapping the screen on mobile
                startGame();
            }
        });

        canvas.addEventListener('pointerup', (e) => {
            e.preventDefault();
            if (gameState === 'playing') {
                isHoldingJetpack = false;
            }
            try { canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId); } catch (err) {}
        });

        canvas.addEventListener('pointercancel', (e) => {
            if (gameState === 'playing') isHoldingJetpack = false;
        });

        // Prevent context menu on long press
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // On-screen hold button (for small touch screens)
        const touchHoldBtn = document.createElement('button');
        touchHoldBtn.id = 'touchHold';
        touchHoldBtn.className = 'touch-hold hidden player-svg';
        touchHoldBtn.textContent = 'HOLD';
        document.getElementById('gameContainer').appendChild(touchHoldBtn);
        touchHoldBtn.addEventListener('pointerdown', (e) => { e.preventDefault(); isHoldingJetpack = true; try { touchHoldBtn.setPointerCapture && touchHoldBtn.setPointerCapture(e.pointerId); } catch (err) {} });
        touchHoldBtn.addEventListener('pointerup', (e) => { e.preventDefault(); isHoldingJetpack = false; try { touchHoldBtn.releasePointerCapture && touchHoldBtn.releasePointerCapture(e.pointerId); } catch (err) {} });
        touchHoldBtn.addEventListener('pointercancel', () => { isHoldingJetpack = false; });

        // Show touch hold button automatically on touch-capable devices
        try {
            const isTouch = (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) || window.matchMedia('(pointer:coarse)').matches || 'ontouchstart' in window;
            if (isTouch) touchHoldBtn.classList.remove('hidden');
        } catch (err) {}

        // Fullscreen toggle button
        const fsBtn = document.createElement('button');
        fsBtn.id = 'fullscreenBtn';
        fsBtn.className = 'fullscreen-btn player-svg';
        fsBtn.textContent = '‚§¢';
        document.getElementById('gameContainer').appendChild(fsBtn);
        function updateFullscreenButton() {
            const container = document.getElementById('gameContainer');
            const isFs = !!document.fullscreenElement;
            fsBtn.textContent = isFs ? '‚úï' : '‚§¢';
            if (isFs) container.classList.add('fullscreen-active'); else container.classList.remove('fullscreen-active');
            try { resizeCanvas(); } catch (e) {}
        }

        async function toggleFullscreen() {
            const container = document.getElementById('gameContainer');
            try {
                if (!document.fullscreenElement) {
                    if (container.requestFullscreen) await container.requestFullscreen();
                    else if (container.webkitRequestFullscreen) container.webkitRequestFullscreen();
                } else {
                    if (document.exitFullscreen) await document.exitFullscreen();
                    else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
                }
            } catch (err) {
                // ignore fullscreen errors
            }
            // ensure canvas is resized for the new container size
            try { resizeCanvas(); } catch (e) {}
            updateFullscreenButton();
        }

        fsBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleFullscreen(); });
        document.addEventListener('fullscreenchange', updateFullscreenButton);
        document.addEventListener('webkitfullscreenchange', updateFullscreenButton);

        // Attach reliable event listeners to overlay buttons (useful if inline onclick is blocked)
        try {
            const startBtn = document.getElementById('startBeginBtn');
            if (startBtn) {
                startBtn.addEventListener('click', (e) => { e.preventDefault(); startGame(); });
            }
            const startStoreBtn = document.getElementById('startStoreBtn');
            if (startStoreBtn) {
                startStoreBtn.addEventListener('click', (e) => { e.preventDefault(); openStore(); });
            }
            const goRestart = document.getElementById('gameOverRestartBtn');
            if (goRestart) goRestart.addEventListener('click', (e) => { e.preventDefault(); restartGame(); });
            const goStore = document.getElementById('gameOverStoreBtn');
            if (goStore) goStore.addEventListener('click', (e) => { e.preventDefault(); openStore(); });
        } catch (err) {
            // ignore
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'playing') {
                    isHoldingJetpack = true;
                } else if (gameState === 'gameover') {
                    // only allow restart if overlay is visible and interactive
                    if (overlayInteractive) restartGame();
                } else if (gameState === 'start') {
                    // start the run from start screen
                    startGame();
                }
            }
            // Debug keybinds: 1=shield, 2=magnet, 3=speed (only while playing)
            if (e.code === 'Digit1') {
                if (gameState === 'playing') {
                    activatePowerup('shield');
                    console.log('DEBUG: Shield activated');
                }
            }
            if (e.code === 'Digit2') {
                if (gameState === 'playing') {
                    activatePowerup('magnet');
                    console.log('DEBUG: Magnet activated');
                }
            }
            if (e.code === 'Digit3') {
                if (gameState === 'playing') {
                    activatePowerup('speed');
                    console.log('DEBUG: Speed activated');
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'playing') {
                    isHoldingJetpack = false;
                }
            }
        });

        // Prevent context menu on canvas
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Initialize and start game loop
        // Load saved progress and update overlays
        updateStartScreenProgress();
        updateGameOverProgress();
        initAmbientParticles();
        gameLoop();
        // Ensure autosave runs once at load and save on unload
        autosave();
        window.addEventListener('beforeunload', autosave);
    </script>
</body>
</html>